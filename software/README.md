# Software

## モジュール

- Deep モジュールを作ってShallowモジュールは作らない
  - Deep モジュール
    - インターフェイスが狭くて、実装が深いモジュールのこと
    - 公開するメソッド数を最低限にして、メソッドは一つの機能を提供する
    - メソッド数を何個以下にしなければならないみたいなことはないが、モジュールの役割を超えることはやらない
  - Shallow モジュール
    - インターフェイスが広くて、実装が浅いモジュールのこと
    - Getter, Setterはなるべく作らないようにする
    - 不必要にメソッドを公開しないようにする
- 防御的なプログラミングよりも契約的なプログラミングをする
  - 防御的なプログラミング
    - 各モジュールが他のモジュールを信じないで入力値を厳密にチェックして、モジュール単体で品質を担保する考え方
      - 各モジュールが入力値を厳密にチェックして実装されており堅牢にも見えるが、同じような実装が増え結果的に複雑にはなる
      - 複雑性が上がると、その分保守のコストも増え、バグも混入しやすくなる。
  - 契約的なプログラミング
    - プログラミングで守るのではなく、コーディングのルール（契約）でコード全体での品質を担保するような考え方
      - コンパイラやリンタにより強制的に制限を設けて、チェックしなければならない項目を減らす
        - 型宣言をして、型の入力チェックをしない
        - 列挙型を使って、入力値に制限をかける
      - またフレームワークに乗っかって、そのフレームワークのルールにの取ってできることだけをやる
    - できていいことだけができるようにする
      - 柔軟になんでもできるようなメソッドを作らない
        - 余計な事がなんでもできると、その分処理やテストが複雑になる
    - APIの入口などでは入力値をチェックするが、その配下のモジュールは入力値が正しいことを信頼して入力値をチェックしない

## エラーと例外

- エラーとは、とある処理の実施中に何らかの原因で処理を中断しなければならない場合に、その原因のことをエラーと呼びます。
    - エラーが発生した場合、呼び出し元に以下のようなエラー情報を正確に伝搬する必要があります。
        - 何の処理を実行しようとして、何が原因で処理が中断されたか
        - どのファイルの何行目でエラーが発生したか
    - 呼び出し元はエラー情報からなんらかのアクションを実施します。
        - 入力が間違ってる、権限がないなどのエラー情報を返された場合は、それに合わせてユーザは何らかのアクションを実施します。
        - 500のようなエラーの場合は、時間をおいてリトライしたり、リトライしてもだめならサービス窓口に問い合わせをします。
    - リトライについて
        - 何らかのエラーで処理が失敗したときにリトライすることで処理が継続できる場合があります
        - リトライすべきかどうかは状況によって異なりますが、なるべくリトライしてエンドユーザにはそのエラーを見せないようにすべきでしょう
- 例外とは、想定外のプログラムバグやランタイムの原因でプログラム自体を中断しなければならない場合に、その原因のことを例外と呼びます。
  - 例えば、null pointer を参照した、配列の長さを超えるindexを参照した、など

## ロギング

- ログレベルは5段階
    - DEBUG
      - 開発時や問題調査時などに出力するデバッグ用の詳細ログです。
      - ログ量が多くなるので本番などでは基本的に出力しません。
    - INFO
      - アプリケーションの動作を確認するための一般ログです。
      - 例えば、WEBAPIでは、どのクライアントから、どのURLにアクセスされ、何秒で返せたかなどのログを出力します。
      - 例えば、バッチシステムでは、何件処理し、その処理に何後かかったか、また未処理のタスク数を出力したりします。
    - WARN
      - INFOと同様でアプリケーションの動作を確認するための一般ログですが、軽微な警告を表します。
      - 例えば、特定の処理に時間がかかっていてWARNを出したり、リトライで処理は完了できたがWARNだけ出力したりします。
      - WARNが出たからといって運用者が何かをすることはなく、なんらかの問題調査時の手掛かりにする目的で利用されます。
    - ERROR
      - 何らかの原因で正常に処理を完了できなかった場合に、その原因を出力します。
      - ERRORはログ監視で利用されることが多く、特定のERRORログが出力されたら、運用者に通知して対応されることを期待します。
    - FATAL
      - 例外や想定外の入力でプログラムを停止しなければならないような場合に、FATALを出力して直ちにプログラムを停止します。
      - これは運用者がなんらかのアクションをしてプログラムを回復することを期待します。
        - sytemdやk8sでプログラムを動かしてる場合は、自動でプログラムが再起動されて回復されるかもしれません。
        - 自動で回復されない場合は、k8sではCrashLoopBackOffとなり、これは運用者に通知して対応するとよいでしょう。

## トレーシング

- システムは肥大化するにつれて、その処理の調査が困難になります。
- 一つのAPIで処理が完結して入れいればまだましですが、裏で他のシステムと連携していたりすると、その調査は困難になります。
- 大規模システムでよくあるのは、性能的な課題が出てきて、プロファイルを取ってどこの処理でどのくらい時間がかかってるかなどを調査する必要がでてきます。
- トレーシングのやり方
  - ログにTraceIDを仕込むだけ
    - 一つの処理トランザクションごとにTraceIDを作成して、それをコンテキストや、HTTPヘッダを利用して伝搬させて、その処理に関するログに同一のTraceIDを仕込むことです。
    - これを中央のログシステムに送り、TraceIDでフィルタリングすれば簡単なトレーシングができます。
  - OpenTracingを利用する
    - OpenTracingに対応したログシステムが必要になりますが、標準的なやり方でトレーシングをすることができます。
- トレーシングの有効・無効と粒度を切り替えらるようにする
  - ログ流量を気にしなくてよいのでは、トレーシングは常に有効にして、詳細なトレーシングをしてもよいでしょう。
  - 実際の大規模システムには、ログ流量を気にしなければならず、トレーシングは常に有効にはできず、有効化できたとしてもInfoレベルのトレーシングログしか取れないことがあります。
  - また調査目的によっては、Infoレベルのトレーシングで十分な場合もあれば、Debugレベルのトレーシングをしたい場合もあるでしょう。
  - 一つのやり方としては、HTTPヘッダなどにトレーシング用の情報が含まれてた場合にのみトレーシングを有効化したり、トレーシングレベルを切り替えられるとよいでしょう。

## 設定ファイル

- Zero Config による強制
  - だいたい通用する設定なら、あえて設定できないようにするのもあり
  - Goのgofmtは設定項目がなかったり、Pythonのblackもほぼ設定できないが、そのように設定できないほうがよいこともある
    - タブvsスペースなどの変な宗教戦争で思考や時間を浪費する必要がなくなる
- ユーザが設定すべき値は極力最低限にして、デフォルト値を用意する
  - 設定ファイルがなくてもプログラムが動くのが理想
  - モジュールごとに設定値、デフォルトの設定値を持たせる
  - 今の設定、デフォルトの設定を出力できるようにする
- 設定ファイルの指定方法
  - 環境変数 or コマンドラインオプションで指定できるようにする
    - 環境変数だったら、KUBECONFIG, コマンドラインオプションだったら、--kubeconfig のようにする

## 認知負荷

- 人間が頭の中で一度に処理できる情報量には限界があります。
- 人間が新しいことを学ぶときには、ワーキングメモリと呼ばれる一時的なメモリで処理して、そこで理解をして構造化した知識のカタチにして長期メモリに保存します。
- ワーキングメモリに対してかかる負荷を認知不可と呼び、これは以下のタイプに分けられます。
  - 課題内在性負荷
    - 課題そのものが持っている認知負荷のことで、内容が複雑であればあるほど当然負荷は高くなります。
  - 課題外在性負荷
    - 学習課題とは直接関係ない認知負荷のことです。
    - 複雑な指示や、見にくいコード、うるさい環境、失敗したらどうしようという精神的なものなどがこれにあたります。
    - このような負荷はなるべく無くすべきです。
  - 学習関連負荷
    - 知識の構築に役立つ認知不可のことです。
    - 課題そのものと関連した異なる学習が求められて負荷も高まるが、役に立つ良い負荷である。
    - 関連事項も同時に学習でき、一つ一つをまばらに学習するよりも関連事項をまとめて学習できるほうが効率が良いです。
    - とはいえ盛り込みすぎて複雑化するのはよくありません。
- ワーキングメモリには限りがあり、認知負荷が高いと一度に情報を処理しきれず、ワーキングメモリと長期メモリの間で情報を出し入れする必要があり、非効率な学習となります。
- 課題内在性負荷は基本的に減らせないですが、課題外在性負荷はなるべく減らす努力をし、学習関連負荷は減らすのではなく見せ方を工夫するとよいです。
- 認知負荷は、一般的な学習だけでなく、コードやドキュメンテーションなどの読み物全般に当てはまるものです。
- 認知負荷の減らし方
  - 情報源の統一
    - 分散した複数の情報源よりも、統合された一つの情報源からのほうが認知不可が低いです。
    - 詰め込みすぎは注意です。
  - 例題の活用
    - 初心者にとっては自力で一から問題を解くよりも例題やチュートリアルを用いて学習したほうが認知不可が低くなります。
  - モチベーションを上げる
    - ワーキングメモリが上昇したり、精神的な負荷でワーキングメモリが消費されなくなります。
    - モチベーションの上げ方は、人によって様々だが、音楽を聞いたり、休んだり、他人に触発されたりなど自分なりのやり方を確立できるとよいでしょう。
  - 環境
    - 視界や聴覚からインプットされる有害物を排除するとよいです。
    - 視界に動くものがあったり、人の声や騒音などが入ると、そこにリソースを割かれてしまいます。
    - また人によってはスマートフォンが視界にあるだけでも、そこにリソースが割かれてしまいます。